<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet href="documentation.xslt" type="text/xsl" ?>
<lowcode>
    <description>
    The Lowcode instruction set defines a register based virtual machine for
    C like low-level operations and Smalltalk object oriented pointer
    manipulations. <br />

    Lowcode has different set of registers, one for integer, another for
    object-oriented pointers and another for floating point numbers.<br/>
    Lowcode is encoded using the Sista inline primitives and they starting with
    opcode inline primitive.<br />
    </description>Lowcode_setConditionFlagsBySubtractingIntegers

<!--
Some useful Sista extended bytecode instructions
-->
    <sista-instruction firstOpcode="0" lastOpcode="15" mnemonic="pushReceiverVariableSmallIndex">
        <description>Push Receiver Variable</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->fetchPointerofObject(sistaOpcode &amp; 15, receiver));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self interpreterProxy fetchPointer: instruction opcode sistaOpcode &amp; 15 ofObject: receiver.
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->fetchPointerofObject(getOpcode() &amp; 15, getReceiverOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction firstOpcode="16" lastOpcode="31" mnemonic="pushLiteralVariableSmallIndex">
        <description>Push Literal Variable</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            UNIMPLEMENTED();
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self shouldBeImplemented.
        </semantic>

        <semantic language="C++/LLVM">
            abort(); /* Should be implemented */
        </semantic>

    </sista-instruction>

    <sista-instruction firstOpcode="32" lastOpcode="63" mnemonic="pushLiteralSmallIndex">
        <description>Push Literal</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->fetchPointerofObject(sistaOpcode &amp; 31, literals));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self literalAt: instruction opcode &amp; 31.
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->fetchPointerofObject(getOpcode() &amp; 31, getLiteralsOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction firstOpcode="64" lastOpcode="71" mnemonic="pushTempSmallIndex">
        <description>Push Temp</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->fetchPointerofObject(sistaOpcode &amp; 7, temporals));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self temporalAt: instructions opcode &amp; 7.
        </semantic>

        <semantic language="C++/LLVM">
            object = builder.CreateLoad(getTemporalAt(getOpcode() &amp; 7));
        </semantic>

    </sista-instruction>

    <sista-instruction firstOpcode="72" lastOpcode="75" mnemonic="pushTempSmallIndex2">
        <description>Push Temp + 8</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->fetchPointerofObject((sistaOpcode &amp; 3) + 8, temporals));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self temporalAt: instructions opcode &amp; 7 + 8.
        </semantic>

        <semantic language="C++/LLVM">
            object = builder.CreateLoad(getTemporalAt((getOpcode() &amp; 7) + 8));
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="76" mnemonic="pushReceiver">
        <description>Push receiver</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(receiver);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self receiver.
        </semantic>

        <semantic language="C++/LLVM">
            object = getReceiverOopValue();
        </semantic>
    </sista-instruction>

    <sista-instruction opcode="77" mnemonic="pushTrue">
        <description>Push True</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->trueObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self trueObject.
        </semantic>

        <semantic language="C++/LLVM">
            object = getTrueOopValue();
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="78" mnemonic="pushFalse">
        <description>Push False</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->falseObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self falseObject.
        </semantic>

        <semantic language="C++/LLVM">
            object = getFalseOopValue();
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="79" mnemonic="pushNil">
        <description>Push Nil</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->nilObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self nilObject.
        </semantic>

        <semantic language="C++/LLVM">
            object = getNilOopValue();
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="80" mnemonic="pushZero">
        <description>Push Zero</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP_INTEGER(0);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self zeroObject.
        </semantic>

        <semantic language="C++/LLVM">
            object = getZeroOopValue();
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="81" mnemonic="pushOne">
        <description>Push One</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP_INTEGER(1);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            object := self oneObject.
        </semantic>

        <semantic language="C++/LLVM">
            object = getOneOopValue();
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="82" mnemonic="pushThisContext">
        <description>Push This Context</description>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </sista-instruction>

    <sista-instruction opcode="83" mnemonic="dupTop">
        <description>Duplicate Stack Top</description>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <stack-results>
            <oop name="dup1" />
            <oop name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            PUSH_OOP(interpreterProxy->stackValue(0));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := object.
            dup2 := object.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = object;
            dup2 = object;
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="88" mnemonic="returnReceiver" kind="terminator">
        <description>Return Receiver</description>

        <semantic language="C/Interpreter">
            RETURN_OOP(receiver);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: self receiver.
        </semantic>

        <semantic language="C++/LLVM">
            returnOop(getReceiverOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="89" mnemonic="returnTrue" kind="terminator">
        <description>Return True</description>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->trueObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: self trueObject.
        </semantic>

        <semantic language="C++/LLVM">
            returnOop(getTrueOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="90" mnemonic="returnFalse" kind="terminator">
        <description>Return False</description>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->falseObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: self falseObject.
        </semantic>

        <semantic language="C++/LLVM">
            returnOop(getFalseOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="91" mnemonic="returnNil" kind="terminator">
        <description>Return Nil</description>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->nilObject());
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: self nilObject.
        </semantic>

        <semantic language="C++/LLVM">
            returnOop(getNilOopValue());
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="92" mnemonic="returnTop" kind="terminator">
        <description>Return top stack element.</description>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            sqInt top = interpreterProxy->stackValue(0);
            RETURN_OOP(top);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: object.
        </semantic>

        <semantic language="C++/LLVM">
            returnOop(object);
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="95" mnemonic="nop">
        <description>Nop</description>

        <semantic language="C/Interpreter">
            /* Do nothing*/
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            " Do nothing "
        </semantic>

        <semantic language="C++/LLVM">
            // Do nothing.
        </semantic>

    </sista-instruction>

    <sista-instruction opcode="119" mnemonic="sendSpecialMessageClass">
        <description>Pushes the class of the element in the top of the stack.</description>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <stack-results>
            <oop name="objectClass" />
        </stack-results>

        <semantic language="C/Interpreter">
            sqInt object;
            sqInt objectClass;
            POP_OOP_TO(object);
            objectClass = interpreterProxy->fetchClassOf(object);
            CHECK_FAILED();
            PUSH_OOP(objectClass);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            objectClass := self interpreterProxy fetchClassOf: object.
            self checkFailed.
        </semantic>

        <semantic language="C++/LLVM">
            objectClass = getLlvmInterpreterProxy()->fetchClassOf(object);
            checkFailed();
        </semantic>

    </sista-instruction>

    <sista-instruction firstOpcode="208" lastOpcode="215" mnemonic="popAndStoreTemp">
        <description>Pop Stack Top</description>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            sqInt value;
            POP_OOP_TO(value);
            interpreterProxy->storePointerofObjectwithValue(sistaOpcode &amp; 7, temporals, value);
            CHECK_FAILED();
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            (self temporalsAt: instruction opcode &amp; 7) value: object.
        </semantic>

        <semantic language="C++/LLVM">
            builder.CreateStore(object, getTemporalAt(getOpcode() &amp; 7));
        </semantic>
    
    </sista-instruction>

    <sista-instruction opcode="216" mnemonic="popStackTop">
        <description>Pop Stack Top</description>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            sqInt dummy;
            POP_OOP_TO(dummy);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            " Do Nothing "
        </semantic>

        <semantic language="C++/LLVM">
            // Do Nothing
        </semantic>
    </sista-instruction>

<!--
///////////////////////////////////////////////////////////////////////////////
// Stack management
//////////////////////////////////////////////////////////////////////////////
-->
    <instruction opcode="256" mnemonic="duplicateInt32">
        <name>Duplicate Int32</name>
        <description>It duplicates the Int32 present in the top of the stack</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <stack-results>
            <int32 name="dup1" />
            <int32 name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            dup1 = value;
            dup2 = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := value.
            dup2 := value.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = value;
            dup2 = value;
        </semantic>

    </instruction>

    <instruction opcode="257" mnemonic="duplicateInt64">
        <name>Duplicate Int64</name>
        <description>It duplicates the Int64 present in the top of the stack</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <stack-results>
            <int64 name="dup1" />
            <int64 name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            dup1 = value;
            dup2 = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := value.
            dup2 := value.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = value;
            dup2 = value;
        </semantic>

    </instruction>

    <instruction opcode="258" mnemonic="duplicatePointer">
        <name>Duplicate Pointer</name>
        <description>It duplicates the pointer present in the top of the stack</description>

        <stack-arguments>
            <pointer name="value" />
        </stack-arguments>

        <stack-results>
            <pointer name="dup1" />
            <pointer name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            dup1 = value;
            dup2 = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := value.
            dup2 := value.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = value;
            dup2 = value;
        </semantic>

    </instruction>

    <instruction opcode="259" mnemonic="duplicateFloat32">
        <name>Duplicate Float32</name>
        <description>It duplicates the Float32 present in the top of the stack</description>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>

        <stack-results>
            <float32 name="dup1" />
            <float32 name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            dup1 = value;
            dup2 = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := value.
            dup2 := value.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = value;
            dup2 = value;
        </semantic>

    </instruction>

    <instruction opcode="260" mnemonic="duplicateFloat64">
        <name>Duplicate Float64</name>
        <description>It duplicates the Float64 present in the top of the stack</description>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>

        <stack-results>
            <float64 name="dup1" />
            <float64 name="dup2" />
        </stack-results>

        <semantic language="C/Interpreter">
            dup1 = value;
            dup2 = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            dup1 := value.
            dup2 := value.
        </semantic>

        <semantic language="C++/LLVM">
            dup1 = value;
            dup2 = value;
        </semantic>

    </instruction>

    <instruction opcode="261" mnemonic="popInt32">
        <name>Pop Int32</name>
        <description>It removes the Int32 present in the top of the stack</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter" />
        <semantic language="Pharo/VirtualCPU" />
        <semantic language="C++/LLVM" />
    </instruction>

    <instruction opcode="262" mnemonic="popInt64">
        <name>Pop Int64</name>
        <description>It removes the Int64 present in the top of the stack</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter" />
        <semantic language="Pharo/VirtualCPU" />
        <semantic language="C++/LLVM" />
    </instruction>

    <instruction opcode="263" mnemonic="popPointer">
        <name>Pop Pointer</name>
        <description>It removes the Pointer present in the top of the stack</description>

        <stack-arguments>
            <pointer name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter" />
        <semantic language="Pharo/VirtualCPU" />
        <semantic language="C++/LLVM" />
    </instruction>

    <instruction opcode="264" mnemonic="popFloat32">
        <name>Pop Float32</name>
        <description>It removes the Float32 present in the top of the stack</description>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter" />
        <semantic language="Pharo/VirtualCPU" />
        <semantic language="C++/LLVM" />
    </instruction>

    <instruction opcode="265" mnemonic="popFloat64">
        <name>Pop Float64</name>
        <description>It removes the Float64 present in the top of the stack</description>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter" />
        <semantic language="Pharo/VirtualCPU" />
        <semantic language="C++/LLVM" />
    </instruction>

<!--
///////////////////////////////////////////////////////////////////////////////
// Load/Store
//////////////////////////////////////////////////////////////////////////////
-->
    <instruction opcode="266" mnemonic="pushZero32">
        <name>Pushes zero constant</name>
        <description>Pushes a 32 bit zero</description>

        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = 0;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word0.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt32(0);
        </semantic>
    </instruction>

    <instruction opcode="267" mnemonic="pushOne32">
        <name>Push one constant 32-bit integer</name>
        <description>Pushes a 32 bit one constant</description>

        <stack-results>
            <int32 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = 1;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word: 1.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt32(1);
        </semantic>

    </instruction>

    <instruction opcode="268" mnemonic="pushZero64">
        <name>Pushes zero constant</name>
        <description>Pushes a 64 bit zero</description>

        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = 0;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word0.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt64(0);
        </semantic>

    </instruction>

    <instruction opcode="269" mnemonic="pushOne64">
        <name>Push one constant 64-bit integer</name>
        <description>Pushes a 64 bit one constant</description>

        <stack-results>
            <int64 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = 1;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word: 1.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt64(1);
        </semantic>

    </instruction>

    <instruction opcode="270" mnemonic="pushConstantUInt32">
        <name>Push a 32-bit integer constant</name>
        <description>Pushes a 32-bit integer constant.</description>

        <arguments>
            <extend-a name="constant" />
        </arguments>

        <stack-results>
            <int32 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = constant;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word: constant.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt32(constant);
        </semantic>

    </instruction>

    <instruction opcode="271" mnemonic="pushConstantUInt64">
        <name>Push a 64-bit integer constant</name>
        <description>Pushes a 64-bit integer constant.</description>

        <arguments>
            <extend-a name="constant" />
        </arguments>

        <stack-results>
            <int64 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = constant;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word: constant.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.getInt64(0);
        </semantic>

    </instruction>

    <instruction opcode="272" mnemonic="pushZeroFloat32">
        <name>Pushes a zero single precision float constant</name>
        <description>It pushes a single precision float zero</description>

        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = 0;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word0.
        </semantic>

        <semantic language="C++/LLVM">
            result = llvm::ConstantFP::get(builder.getFloatTy(), 0);
        </semantic>

    </instruction>

    <instruction opcode="273" mnemonic="pushOneFloat32">
        <name>Push a single precision one constant</name>
        <description>It pushes a single precision float of one</description>

        <stack-results>
            <float32 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = 1;
        </semantic>

        <semantic language="C++/LLVM">
            result = llvm::ConstantFP::get(builder.getFloatTy(), 1);
        </semantic>

    </instruction>

    <instruction opcode="274" mnemonic="pushZeroFloat64">
        <name>Pushes a zero single precision float constant</name>
        <description>It pushes a single precision float zero</description>

        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = 0;
        </semantic>

        <semantic language="C++/LLVM">
            result = llvm::ConstantFP::get(builder.getDoubleTy(), 0);
        </semantic>

    </instruction>

    <instruction opcode="275" mnemonic="pushOneFloat64">
        <name>Push a single precision one constant</name>
        <description>It pushes a single precision float of one</description>

        <stack-results>
            <float64 name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = 1;
        </semantic>

        <semantic language="C++/LLVM">
            result = llvm::ConstantFP::get(builder.getDoubleTy(), 1);
        </semantic>
    </instruction>

    <instruction opcode="276" mnemonic="pushNullPointer">
        <name>Push Null Pointer</name>
        <description>It pushes a null pointer</description>

        <stack-results>
            <pointer name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = 0;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := vcpu word0.
        </semantic>

        <semantic language="C++/LLVM">
            result = llvm::ConstantPointerNull::get(builder.getInt8PtrTy());
        </semantic>

    </instruction>

    <instruction opcode="277" mnemonic="pushSessionIdentifier">
        <name>Pushes the unique session identifier</name>
        <description>Computes a new pointer by offseting an old one.</description>
        <stack-arguments />

        <stack-results>
            <int32 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            if(!Lowcode_sessionInitialized)
                Lowcode_initializeSession();
            value = Lowcode_sessionIdentifier;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := self sessionIdentifier.
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.getInt32(LowcodeLLVMContext::get().getSessionIdentifier());
        </semantic>

    </instruction>

    <instruction opcode="278" mnemonic="checkSessionIdentifier">
        <name>Pushes true or false if the session ID matches</name>
        <description>Computes a new pointer by offseting an old one.</description>

        <arguments>
            <extend-a name="expectedSession" />
        </arguments>

        <stack-arguments />

        <stack-results>
            <int32 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            if(!Lowcode_sessionInitialized)
                Lowcode_initializeSession();
            value = expectedSession == Lowcode_sessionIdentifier;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := expectedSession = (self sessionIdentifier).
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.getInt32(expectedSession == LowcodeLLVMContext::get().getSessionIdentifier());
        </semantic>

    </instruction>

    <instruction opcode="279" mnemonic="pointerOffset32">
        <name>Adds an offset to a pointer</name>
        <description>Computes a new pointer by offseting an old one.</description>
        <stack-arguments>
            <pointer name="base" />
            <int32 name="offset" />
        </stack-arguments>

        <stack-results>
            <pointer name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((char*)base) + offset;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := base + offset.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateGEP(base, offset);
        </semantic>

    </instruction>

    <instruction opcode="280" mnemonic="pointerOffset64">
        <name>Adds an offset to a pointer</name>
        <description>Computes a new pointer by offseting an old one.</description>
        <stack-arguments>
            <pointer name="base" />
            <int64 name="offset" />
        </stack-arguments>

        <stack-results>
            <pointer name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((char*)base) + offset;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := base + offset.
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateGEP(base, offset);
        </semantic>

    </instruction>


    <instruction opcode="281" mnemonic="effectiveAddress32">
        <name>Compute Effective Address 32-bit</name>
        <description>It computes an effective address 32-bit factors.</description>
        <stack-arguments>
            <pointer name="base" />
            <int32 name="index" />
            <int32 name="scale" />
            <int32 name="offset" />
        </stack-arguments>

        <stack-results>
            <pointer name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((char*)base) + index*scale + offset;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := base + (index*scale) + offset.
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *newOffset = builder.CreateAdd(offset, builder.CreateMul(scale, index));
            result = builder.CreateGEP(base, newOffset);
        </semantic>

    </instruction>

    <instruction opcode="282" mnemonic="effectiveAddress64">
        <name>Compute Effective Address 64-bit</name>
        <description>It computes an effective address using 64-bit factors.</description>
        <stack-arguments>
            <pointer name="base" />
            <int64 name="index" />
            <int64 name="scale" />
            <int64 name="offset" />
        </stack-arguments>

        <stack-results>
            <pointer name="result"/>
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((char*)base) + index*scale + offset;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            result := base + (index*scale) + offset.
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *newOffset = builder.CreateAdd(offset, builder.CreateMul(scale, index));
            result = builder.CreateGEP(base, newOffset);
        </semantic>

    </instruction>

    <instruction opcode="283" mnemonic="loadUInt8FromMemory">
        <name>Load U8 from Memory</name>
        <description>Loads an U8 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint32_t)*((uint8_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="284" mnemonic="loadUInt16FromMemory">
        <name>Load U16 from Memory</name>
        <description>It loads an U16 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint32_t)*((uint16_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));
            value = builder.CreateZExt(builder.CreateLoad(castedPointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="285" mnemonic="loadUInt32FromMemory">
        <name>Load U32 from Memory</name>
        <description>Loads an U32 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((uint32_t*)pointer);
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := pointer readWord.
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="286" mnemonic="loadUInt64FromMemory">
        <name>Load U64 from Memory</name>
        <description>Loads an U64 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((uint64_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="287" mnemonic="loadInt8FromMemory">
        <name>Load I8 from Memory</name>
        <description>Loads an I8 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((int8_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="288" mnemonic="loadInt16FromMemory">
        <name>Load U16 from Memory</name>
        <description>Loads an U16 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((int16_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));
            value = builder.CreateSExt(builder.CreateLoad(castedPointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="289" mnemonic="loadInt32FromMemory">
        <name>Load I32 from Memory</name>
        <description>Loads an I32 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((int32_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="290" mnemonic="loadInt64FromMemory">
        <name>Load I64 from Memory</name>
        <description>Loads an I64 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((int64_t*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="291" mnemonic="loadPointerFromMemory">
        <name>Load Pointer from Memory</name>
        <description>Loads a pointer from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <pointer name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((void**)pointer);
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := pointer readWord.
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Type *pointerType = llvm::PointerType::getUnqual(llvm::Type::getInt8PtrTy(builder.getContext()));
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, pointerType);
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="292" mnemonic="loadFloat32FromMemory">
        <name>Load Float 32 from Memory</name>
        <description>Loads a float 32 from memory.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <float32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((float*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getFloatPtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="293" mnemonic="loadFloat64FromMemory">
        <name>Load Float 64 from Memory</name>
        <description>Loads a float 64 from.</description>
        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <stack-results>
            <float64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((double*)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getDoublePtrTy(builder.getContext()));
            value = builder.CreateLoad(castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="294" mnemonic="storeInt8ToMemory">
        <name>Store UInt8 in memory</name>
        <description>Stores an U8 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <int32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((int8_t*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedValue = builder.CreateTrunc(value, builder.getInt8Ty());
            builder.CreateStore(castedValue, pointer);
        </semantic>

    </instruction>

    <instruction opcode="295" mnemonic="storeInt16ToMemory">
        <name>Store UInt16 in memory</name>
        <description>Stores an U16 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <int32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((int16_t*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedValue = builder.CreateTrunc(value, builder.getInt16Ty());
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt16PtrTy(builder.getContext()));
            builder.CreateStore(castedValue, castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="296" mnemonic="storeInt32ToMemory">
        <name>Store UInt32 in memory</name>
        <description>Stores an U32 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <int32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((int32_t*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt32PtrTy(builder.getContext()));
            builder.CreateStore(value, castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="297" mnemonic="storeInt64ToMemory">
        <name>Store Int64 in memory</name>
        <description>It stores an I64 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <int64 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((int64_t*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getInt64PtrTy(builder.getContext()));
            builder.CreateStore(value, castedPointer);
        </semantic>
    </instruction>

    <instruction opcode="298" mnemonic="storePointerToMemory">
        <name>Store a pointer in memory</name>
        <description>Stores pointer int the memory.</description>

        <stack-arguments>
            <pointer name="memoryPointer" />
            <pointer name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((void**)memoryPointer) = value;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            memoryPointer writeWord: value.
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Type *pointerType = llvm::PointerType::getUnqual(llvm::Type::getInt8PtrTy(builder.getContext()));
            llvm::Value *castedPointer = builder.CreatePointerCast(memoryPointer, pointerType);
            builder.CreateStore(value, castedPointer);
        </semantic>

    </instruction>

    <instruction opcode="299" mnemonic="storeFloat32ToMemory">
        <name>Store Float32 in memory</name>
        <description>Stores a Float32 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <float32 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((float*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getFloatPtrTy(builder.getContext()));
            builder.CreateStore(value, castedPointer);
        </semantic>
    </instruction>

    <instruction opcode="300" mnemonic="storeFloat64ToMemory">
        <name>Store Float64 in memory</name>
        <description>Stores a Float64 value to the memory.</description>

        <stack-arguments>
            <pointer name="pointer" />
            <float64 name="value" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            *((double*)pointer) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *castedPointer = builder.CreatePointerCast(pointer, llvm::Type::getDoublePtrTy(builder.getContext()));
            builder.CreateStore(value, castedPointer);
        </semantic>
    </instruction>

    <instruction opcode="301" mnemonic="loadLocalAddress">
        <name>Load local address</name>
        <description>It loads a local variable address in the stack</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = basePointer + baseOffset;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            pointer := self basePointer + baseOffset.
        </semantic>

        <semantic language="C++/LLVM">
            pointer = getLocalPointer(baseOffset);
        </semantic>

    </instruction>

    <instruction opcode="302" mnemonic="loadLocalUInt8">
        <name>Load U8 from stack</name>
        <description>It Loads an U8 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint32_t)*((uint8_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());
            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="303" mnemonic="loadLocalUInt16">
        <name>Load U16 from stack</name>
        <description>It Loads an U16 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint32_t)*((uint16_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());
            value = builder.CreateZExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="304" mnemonic="loadLocalUInt32">
        <name>Load U32 from stack</name>
        <description>It Loads an U32 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint32_t)*((uint32_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="305" mnemonic="loadLocalUInt64">
        <name>Load U8 from stack</name>
        <description>It Loads an U8 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (uint64_t)*((uint64_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="306" mnemonic="loadLocalInt8">
        <name>Load I8 from stack</name>
        <description>It Loads an U8 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (int32_t)*((int8_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());
            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="307" mnemonic="loadLocalInt16">
        <name>Load I16 from stack</name>
        <description>It Loads an U16 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (int32_t)*((int16_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());
            value = builder.CreateSExt(builder.CreateLoad(pointer), builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="308" mnemonic="loadLocalInt32">
        <name>Load I32 from stack</name>
        <description>It Loads an U32 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (int32_t)*((int32_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="309" mnemonic="loadLocalInt64">
        <name>Load I64 from stack</name>
        <description>It Loads an I64 from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (int64_t)*((int64_t*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="310" mnemonic="loadLocalPointer">
        <name>Load pointer from stack</name>
        <description>It loads a pointer from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <pointer name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = (void*)*((void**)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8PtrTy());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="311" mnemonic="loadLocalFloat32">
        <name>Load single precision float from stack</name>
        <description>It loads a single precision float from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <float32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((float*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getFloatTy());
            value = builder.CreateLoad(pointer);
        </semantic>

    </instruction>

    <instruction opcode="312" mnemonic="loadLocalFloat64">
        <name>Load double precision float from stack</name>
        <description>It loads a double precision float from the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-results>
            <float64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = *((double*)(basePointer + baseOffset));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getDoubleTy());
            value = builder.CreateLoad(pointer);
        </semantic>
    </instruction>

    <instruction opcode="313" mnemonic="storeLocalInt8">
        <name>Store I8 to stack frame</name>
        <description>It stores an I8 to the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((int8_t*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8Ty());
            builder.CreateStore(builder.CreateTrunc(value, builder.getInt8Ty()), pointer);
        </semantic>

    </instruction>

    <instruction opcode="314" mnemonic="storeLocalInt16">
        <name>Store I16 to stack frame</name>
        <description>It stores an I16 to the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((int16_t*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt16Ty());
            builder.CreateStore(builder.CreateTrunc(value, builder.getInt16Ty()), pointer);
        </semantic>

    </instruction>

    <instruction opcode="315" mnemonic="storeLocalInt32">
        <name>Store I32 to stack frame</name>
        <description>It stores an I32 to the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((int32_t*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt32Ty());
            builder.CreateStore(value, pointer);
        </semantic>

    </instruction>

    <instruction opcode="316" mnemonic="storeLocalInt64">
        <name>Store I64 to stack frame</name>
        <description>It stores an I64 to the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((int64_t*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt64Ty());
            builder.CreateStore(value, pointer);
        </semantic>

    </instruction>

    <instruction opcode="317" mnemonic="storeLocalPointer">
        <name>Store pointer in the stack frame</name>
        <description>It stores a pointer in the stack frame memory.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <pointer name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((void**)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getInt8PtrTy());
            builder.CreateStore(value, pointer);
        </semantic>

    </instruction>

    <instruction opcode="318" mnemonic="storeLocalFloat32">
        <name>Store single precision float in the stack frame</name>
        <description>It stores a single precision float in the stack frame..</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((float*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getFloatTy());
            builder.CreateStore(value, pointer);
        </semantic>

    </instruction>

    <instruction opcode="319" mnemonic="storeLocalFloat64">
        <name>Store double precision float in the stack frame</name>
        <description>It stores a double precision float in the stack frame.</description>
        <arguments>
            <extend-a name="baseOffset" />
        </arguments>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            *((double*)(basePointer + baseOffset)) = value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *pointer = getLocalPointerCasted(baseOffset, builder.getDoubleTy());
            builder.CreateStore(value, pointer);
        </semantic>

    </instruction>

<!--
///////////////////////////////////////////////////////////////////////////////
// ALU Operations
//////////////////////////////////////////////////////////////////////////////
-->

    <instruction opcode="320" mnemonic="signExtend32From8">
        <name>Sign Extend 8-bit</name>
        <description>Sign extends a 8-bit integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());
            result = builder.CreateSExt(small, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="321" mnemonic="signExtend32From16">
        <name>Sign Extend 16-bit</name>
        <description>Sign extends a 16 bit integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());
            result = builder.CreateSExt(small, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="322" mnemonic="signExtend64From8">
        <name>Sign Extend 8-bit</name>
        <description>Sign extends a 8-bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());
            result = builder.CreateSExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="323" mnemonic="signExtend64From16">
        <name>Sign Extend 16-bit</name>
        <description>Sign extends a 16 bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());
            result = builder.CreateSExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="324" mnemonic="signExtend64From32">
        <name>Sign Extend 32-bit</name>
        <description>Sign extends a 32 bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt32Ty());
            result = builder.CreateSExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="325" mnemonic="zeroExtend32From8">
        <name>Zero Extend 8-bit</name>
        <description>Zero extends a 8-bit integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());
            result = builder.CreateZExt(small, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="326" mnemonic="zeroExtend32From16">
        <name>Zero Extend 16-bit</name>
        <description>Zero extends a 16 bit integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());
            result = builder.CreateZExt(small, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="327" mnemonic="zeroExtend64From8">
        <name>Zero Extend 8-bit</name>
        <description>Zero extends a 8-bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt8Ty());
            result = builder.CreateZExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="328" mnemonic="zeroExtend64From16">
        <name>Sign Extend 16-bit</name>
        <description>Sign extends a 16 bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt16Ty());
            result = builder.CreateZExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="329" mnemonic="zeroExtend64From32">
        <name>Sign Extend 32-bit</name>
        <description>Sign extends a 32 bit integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *small = builder.CreateTrunc(value, builder.getInt32Ty());
            result = builder.CreateZExt(small, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="330" mnemonic="truncate32To8">
        <name>Truncate 32-bit to 8-bit integer</name>
        <description>Truncates an integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateAnd(value, 0xFF);
        </semantic>

    </instruction>

    <instruction opcode="331" mnemonic="truncate32To16">
        <name>Truncate 32-bit to 16-bit integer</name>
        <description>Truncates an integer value.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateAnd(value, 0xFFFF);
        </semantic>

    </instruction>

    <instruction opcode="332" mnemonic="truncate64To8">
        <name>Truncate 64-bit to 8-bit integer</name>
        <description>Truncates an integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint8_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateAnd(value, 0xFF);
        </semantic>

    </instruction>

    <instruction opcode="333" mnemonic="truncate64To16">
        <name>Truncate 64-bit to 16-bit integer</name>
        <description>Truncates an integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint16_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateAnd(value, 0xFFFF);
        </semantic>

    </instruction>

    <instruction opcode="334" mnemonic="truncate64To32">
        <name>Truncate 64-bit to 32-bit integer</name>
        <description>Truncates an integer value.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateAnd(value, 0xFFFFFFFF);
        </semantic>

    </instruction>

    <instruction opcode="335" mnemonic="uint32ToFloat32">
        <name>UInt32 to Float32</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateUIToFP(value, builder.getFloatTy());
        </semantic>

    </instruction>

    <instruction opcode="336" mnemonic="uint32ToFloat64">
        <name>UInt32 to Float64</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateUIToFP(value, builder.getDoubleTy());
        </semantic>

    </instruction>

    <instruction opcode="337" mnemonic="int32ToFloat32">
        <name>Int32 to Float32</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateSIToFP(value, builder.getFloatTy());
        </semantic>

    </instruction>

    <instruction opcode="338" mnemonic="int32ToFloat64">
        <name>Int32 to Float64</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateSIToFP(value, builder.getDoubleTy());
        </semantic>

    </instruction>

    <instruction opcode="339" mnemonic="uint64ToFloat32">
        <name>UInt64 to Float32</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateUIToFP(value, builder.getFloatTy());
        </semantic>

    </instruction>

    <instruction opcode="340" mnemonic="uint64ToFloat64">
        <name>UInt64 to Float64</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateUIToFP(value, builder.getDoubleTy());
        </semantic>

    </instruction>

    <instruction opcode="341" mnemonic="int64ToFloat32">
        <name>Int64 to Float32</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateSIToFP(value, builder.getFloatTy());
        </semantic>

    </instruction>

    <instruction opcode="342" mnemonic="int64ToFloat64">
        <name>Int64 to Float64</name>
        <description>Converts an unsigned integer into a floating point number.</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateSIToFP(value, builder.getDoubleTy());
        </semantic>

    </instruction>

    <instruction opcode="343" mnemonic="float32ToInt32">
        <name>Float32 to Int32</name>
        <description>It converts single precision floating point number into 32-bit integer.</description>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateFPToSI(value, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="344" mnemonic="float64ToInt32">
        <name>Float64 to Int32</name>
        <description>It converts double precision floating point number into a 32-bit integer.</description>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateFPToSI(value, builder.getInt32Ty());
        </semantic>

    </instruction>

    <instruction opcode="345" mnemonic="float32ToInt64">
        <name>Float32 to Int64</name>
        <description>It converts a single precision floating point number into a 64-bit integer.</description>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateFPToSI(value, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="346" mnemonic="float64ToInt64">
        <name>Float64 to Int64</name>
        <description>It converts a double precision floating point number into a 64-bit integer.</description>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int64_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateFPToSI(value, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="347" mnemonic="pointerToInt32">
        <name>Pointer to Int32</name>
        <description>It converts a pointer into a 32-bit integer.</description>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int32_t)((uintptr_t)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreatePtrToInt(pointer, builder.getInt32Ty());
        </semantic>
    </instruction>

    <instruction opcode="348" mnemonic="pointerToInt64">
        <name>Pointer to Int64</name>
        <description>It converts a pointer into a 64-bit integer.</description>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (int64_t)((uintptr_t)pointer);
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreatePtrToInt(pointer, builder.getInt64Ty());
        </semantic>

    </instruction>

    <instruction opcode="349" mnemonic="int32ToPointer">
        <name>Int32 to Pointer</name>
        <description>It converts a 32-bit integer into a pointer.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <pointer name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (void*)(uintptr_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreateIntToPtr(value, builder.getInt8PtrTy());
        </semantic>

    </instruction>

    <instruction opcode="350" mnemonic="int64ToPointer">
        <name>Int64 to Pointer</name>
        <description>It converts a 64-bit integer into a pointer.</description>

        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <pointer name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (void*)(uintptr_t)value;
        </semantic>

        <semantic language="C++/LLVM">
            result = builder.CreatePtrToInt(value, builder.getInt8PtrTy());
        </semantic>

    </instruction>

    <!-- Integer arithmetics -->
    <instruction opcode="351" mnemonic="add32">
        <name>Integer Addition</name>
        <description>Integer addition without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first + second;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first + second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAdd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="352" mnemonic="sub32">
        <name>Integer Subtraction</name>
        <description>Integer subtraction without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first - second;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first - second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSub(first, second);
        </semantic>

    </instruction>

    <instruction opcode="353" mnemonic="neg32">
        <name>Integer Negation</name>
        <description>Integer negation.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = -value;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateNeg(value);
        </semantic>

    </instruction>

    <instruction opcode="354" mnemonic="mul32">
        <name>Integer Signed Multiplication</name>
        <description>Integer multiplication without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first * second;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first * second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="355" mnemonic="umul32">
        <name>Integer Unsigned Multiplication</name>
        <description>Integer addition without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint32_t)first * (uint32_t)second;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first * second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="356" mnemonic="div32">
        <name>Integer Signed Division</name>
        <description>Integer signed division without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first / second;
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first / second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSDiv(first, second);
        </semantic>

    </instruction>

    <instruction opcode="357" mnemonic="udiv32">
        <name>Integer Unsigned division</name>
        <description>Integer unsigned division without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint32_t)first) / ((uint32_t)second);
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            result := first / second.
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateUDiv(first, second);
        </semantic>

    </instruction>

    <instruction opcode="358" mnemonic="rem32">
        <name>Integer Signed Remainder</name>
        <description>Integer signed remainder without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first % second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSRem(first, second);
        </semantic>

    </instruction>

    <instruction opcode="359" mnemonic="urem32">
        <name>Integer Unsigned remainder</name>
        <description>Integer unsigned remainder without overflow check.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint32_t)first) % ((uint32_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateURem(first, second);
        </semantic>

    </instruction>

    <instruction opcode="360" mnemonic="add64">
        <name>Integer Addition</name>
        <description>Integer addition without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first + second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAdd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="361" mnemonic="sub64">
        <name>Integer Subtraction</name>
        <description>Integer subtraction without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first - second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSub(first, second);
        </semantic>

    </instruction>

    <instruction opcode="362" mnemonic="neg64">
        <name>Integer Negation</name>
        <description>Integer negation.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = -value;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateNeg(value);
        </semantic>

    </instruction>
    <instruction opcode="363" mnemonic="mul64">
        <name>Integer Signed Multiplication</name>
        <description>Integer multiplication without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first * second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="364" mnemonic="umul64">
        <name>Integer Unsigned Multiplication</name>
        <description>Integer addition without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = (uint64_t)first * (uint64_t)second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="365" mnemonic="div64">
        <name>Integer Signed Division</name>
        <description>Integer signed division without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first / second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSDiv(first, second);
        </semantic>

    </instruction>

    <instruction opcode="366" mnemonic="udiv64">
        <name>Integer Unsigned division</name>
        <description>Integer unsigned division without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint64_t)first) / ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateUDiv(first, second);
        </semantic>

    </instruction>

    <instruction opcode="367" mnemonic="rem64">
        <name>Integer Signed Remainder</name>
        <description>Integer signed remainder without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first % second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateSRem(first, second);
        </semantic>

    </instruction>

    <instruction opcode="368" mnemonic="urem64">
        <name>Integer Unsigned remainder</name>
        <description>Integer unsigned remainder without overflow check.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint64_t)first) % ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateURem(first, second);
        </semantic>

    </instruction>

    <!-- Bitwise operations -->
    <instruction opcode="369" mnemonic="not32">
        <name>Bitwise Not</name>
        <description>Performs a bitwise not.</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ~value;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateNot(value);
        </semantic>

    </instruction>

    <instruction opcode="370" mnemonic="and32">
        <name>Bitwise And</name>
        <description>Performs a bitwise and operation.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first &amp; second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAnd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="371" mnemonic="or32">
        <name>Bitwise Or</name>
        <description>Performs a bitwise or operation.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first | second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateOr(first, second);
        </semantic>

    </instruction>

    <instruction opcode="372" mnemonic="xor32">
        <name>Bitwise Xor</name>
        <description>Performs a bitwise xor operation.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first ^ second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateXor(first, second);
        </semantic>

    </instruction>

    <instruction opcode="373" mnemonic="leftShift32">
        <name>Left Shift</name>
        <description>Performs a left shifting.</description>
        <stack-arguments>
            <int32 name="value" />
            <int32 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = value &lt;&lt; shiftAmount;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateShl(value, shiftAmount);
        </semantic>

    </instruction>

    <instruction opcode="374" mnemonic="rightShift32">
        <name>Right Shift</name>
        <description>Performs a right shifting.</description>
        <stack-arguments>
            <int32 name="value" />
            <int32 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint32_t)value) &gt;&gt; ((uint32_t)shiftAmount);
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateLShr(value, shiftAmount);
        </semantic>

    </instruction>

    <instruction opcode="375" mnemonic="arithmeticRightShift32">
        <name>Arithmetic Right Shift</name>
        <description>Performs an arithmetic right shifting.</description>
        <stack-arguments>
            <int32 name="value" />
            <int32 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = value &gt;&gt; shiftAmount;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAShr(value, shiftAmount);
        </semantic>

    </instruction>

    <instruction opcode="376" mnemonic="not64">
        <name>Bitwise Not</name>
        <description>Performs a bitwise not.</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ~value;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateNot(value);
        </semantic>

    </instruction>

    <instruction opcode="377" mnemonic="and64">
        <name>Bitwise And</name>
        <description>Performs a bitwise and operation.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first &amp; second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAnd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="378" mnemonic="or64">
        <name>Bitwise Or</name>
        <description>Performs a bitwise or operation.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first | second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateOr(first, second);
        </semantic>

    </instruction>

    <instruction opcode="379" mnemonic="xor64">
        <name>Bitwise Xor</name>
        <description>Performs a bitwise xor operation.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first ^ second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateXor(first, second);
        </semantic>

    </instruction>

    <instruction opcode="380" mnemonic="leftShift64">
        <name>Left Shift</name>
        <description>Performs a left shifting.</description>
        <stack-arguments>
            <int64 name="value" />
            <int64 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = value &lt;&lt; shiftAmount;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateShl(value, shiftAmount);
        </semantic>

    </instruction>

    <instruction opcode="381" mnemonic="rightShift64">
        <name>Right Shift</name>
        <description>Performs a right shifting.</description>
        <stack-arguments>
            <int64 name="value" />
            <int64 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = ((uint64_t)value) &gt;&gt; ((uint64_t)shiftAmount);
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateLShr(value, shiftAmount);
        </semantic>

    </instruction>

    <instruction opcode="382" mnemonic="arithmeticRightShift64">
        <name>Arithmetic Right Shift</name>
        <description>Performs an arithmetic right shifting.</description>
        <stack-arguments>
            <int64 name="value" />
            <int64 name="shiftAmount" />
        </stack-arguments>
        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = value &gt;&gt; shiftAmount;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateAShr(value, shiftAmount);
        </semantic>

    </instruction>

    <!-- Floating point arithmetic -->
    <instruction opcode="383" mnemonic="float32Add">
        <name>Float32 addition</name>
        <description>It Performs the addition of two single precision floating point numbers.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first + second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFAdd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="384" mnemonic="float32Sub">
        <name>Float32 subtraction</name>
        <description>It performs the subtraction of two single precision floating point numbers.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first - second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFSub(first, second);
        </semantic>

    </instruction>

    <instruction opcode="385" mnemonic="float32Mul">
        <name>Float32 multiplication</name>
        <description>It performs the multiplication of two single precision floating point numbers.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first * second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="386" mnemonic="float32Div">
        <name>Float32 division</name>
        <description>It performs the division of two single precision floating point numbers.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>
        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first / second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFDiv(first, second);
        </semantic>

    </instruction>

    <instruction opcode="387" mnemonic="float64Add">
        <name>Float64 addition</name>
        <description>It performs the addition of two double precision floating point numbers.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first + second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFAdd(first, second);
        </semantic>

    </instruction>

    <instruction opcode="388" mnemonic="float64Sub">
        <name>Float64 subtraction</name>
        <description>It performs the subtraction of two double precision floating point numbers.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first - second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFSub(first, second);
        </semantic>

    </instruction>

    <instruction opcode="389" mnemonic="float64Mul">
        <name>Float32 multiplication</name>
        <description>It performs the multiplication of two double precision floating point numbers.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first * second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFMul(first, second);
        </semantic>

    </instruction>

    <instruction opcode="390" mnemonic="float64Div">
        <name>Float64 division</name>
        <description>It performs the division of two double precision floating point numbers.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>
        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            result = first / second;
        </semantic>

        <semantic language="C++/LLVM" >
            result = builder.CreateFDiv(first, second);
        </semantic>

    </instruction>

    <!-- Oop pinning -->
    <instruction opcode="391" mnemonic="pin">
        <name>Pin Object</name>
        <description>Pins an Oop pointed object</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            /* TODO: Requires Spur */
        </semantic>
    </instruction>

    <instruction opcode="392" mnemonic="unpin">
        <name>Unpin Object</name>
        <description>Unpins an Oop pointed object</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            /* TODO: Requires Spur */
        </semantic>
    </instruction>

    <instruction opcode="393" mnemonic="oopToPointer">
        <name>Oop to Pointer</name>
        <description>Extracts a pointer encoded in an indexable such as NBExternalAddress.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = *((void**)interpreterProxy->firstIndexableField(object));
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *indexablePtr = getLlvmInterpreterProxy()->firstIndexableField(object);
            llvm::Type *ptrType = llvm::PointerType::getUnqual(builder.getInt8PtrTy());
            pointer = builder.CreateLoad(builder.CreatePointerCast(indexablePtr, ptrType));
        </semantic>

    </instruction>

    <instruction opcode="394" mnemonic="oopToPointerReinterpret">
        <name>Cast Oop to Pointer Reinterpret</name>
        <description>Reinterpret casts an Oop into a pointer.
        </description>
        <warning>The Oop should be pinned for safety.</warning>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = (void*)object;
        </semantic>

        <semantic language="C++/LLVM">
            pointer = builder.CreateIntToPtr(object, builder.getInt8PtrTy());
        </semantic>

    </instruction>

    <instruction opcode="395" mnemonic="pointerToOop">
        <name>Pointer to Oop</name>
        <description>Encapsulates a pointer in an object</description>
        <arguments>
            <literal name="pointerClassLiteral" />
        </arguments>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));
            CHECK_FAILED();
            *((void**)interpreterProxy->firstIndexableField(object)) = pointer;
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));
            checkFailed();

            llvm::Value *content = getLlvmInterpreterProxy()->firstIndexableField(object);
            llvm::Type *pointerType = llvm::PointerType::getUnqual(builder.getInt8PtrTy());
            builder.CreateStore(pointer, builder.CreatePointerCast(content, pointerType));
        </semantic>

    </instruction>

    <instruction opcode="396" mnemonic="pointerToOopReinterprer">
        <name>Casts Pointer to Oop Reinterpret</name>
        <description>Reinterpret casts a pointer into an Oop.
        </description>
        <warning>The pointer should have been pinned before.</warning>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = (sqInt)pointer;
        </semantic>

        <semantic language="C++/LLVM">
            object = builder.CreatePtrToInt(pointer, LowcodeLLVMContext::get().getSqIntType());
        </semantic>

    </instruction>

    <instruction opcode="397" mnemonic="instantiateOop">
        <name>Instantiate an oop class</name>
        <description>It instantiates a class</description>

        <stack-arguments>
            <oop name="classOop" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = instantiateClassindexableSize(classOop, 0);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->instantiateClassindexableSize(classOop, 0);
        </semantic>

    </instruction>

    <instruction opcode="398" mnemonic="instantiateIndexableOop">
        <name>Instantiate an indexable class</name>
        <description>It instantiates a class</description>

        <arguments>
            <extend-a name="indexableSize" />
        </arguments>

        <stack-arguments>
            <oop name="classOop" />
        </stack-arguments>

        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = instantiateClassindexableSize(classOop, indexableSize);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->instantiateClassindexableSize(classOop, indexableSize);
        </semantic>

    </instruction>

    <instruction opcode="399" mnemonic="instantiateIndexable32Oop">
        <name>Instantiate an oop class</name>
        <description>It instantiates a class</description>

        <stack-arguments>
            <oop name="classOop" />
            <int32 name="indexableSize" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = instantiateClassindexableSize(classOop, indexableSize);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->instantiateClassindexableSize(classOop, indexableSize);
        </semantic>

    </instruction>

    <!-- Oop Primitive Conversion -->
    <instruction opcode="400" mnemonic="oopToBoolean32">
        <name>Oop to Boolean</name>
        <description>Decodes an Oop representing a boolean into an integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->booleanValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->booleanValueOf(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="401" mnemonic="oopToBoolean64">
        <name>Oop to Boolean</name>
        <description>Decodes an Oop representing a boolean into an integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->booleanValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->booleanValueOf(object), builder.getInt64Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="402" mnemonic="oopSmallIntegerToInt32">
        <name>Oop to Int</name>
        <description>It decodes an Oop representing a small integer into an integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->integerValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->integerValueOf(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="403" mnemonic="oopToInt32">
        <name>Oop to Int</name>
        <description>It decodes an Oop an integer into signed 32-bit integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->signed32BitValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->signed32BitValueOf(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="404" mnemonic="oopToUInt32">
        <name>Oop to Int</name>
        <description>It decodes an Oop representing an integer into an unsigned 32-bit integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->positive32BitValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->positive32BitValueOf(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="405" mnemonic="oopSmallIntegerToInt64">
        <name>Oop to Int</name>
        <description>It decodes an Oop representing a small integer boolean into a64-bit integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->integerValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->integerValueOf(object), builder.getInt64Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="406" mnemonic="oopToInt64">
        <name>Oop to Int</name>
        <description>It decodes an Oop representing a signed integer into a 64-bit integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->signed64BitValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->signed64BitValueOf(object), builder.getInt64Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="407" mnemonic="oopToUInt64">
        <name>Oop to Int</name>
        <description>It decodes an Oop representing an unsigned integer into a 64-bit integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->positive64BitValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->positive64BitValueOf(object), builder.getInt64Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="408" mnemonic="oopToFloat32">
        <name>Oop to Int</name>
        <description>
            It decodes an Oop representing floating point number into a single
            precision IEEE-754 floating point number.
        </description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <float32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->floatValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateFPCast(getLlvmInterpreterProxy()->floatValueOf(object), builder.getFloatTy());
        </semantic>

    </instruction>

    <instruction opcode="409" mnemonic="oopToFloat64">
        <name>Oop to Int</name>
        <description>
            It decodes an Oop representing floating point number into a double
            precision IEEE-754 floating point number.
        </description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <float64 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->floatValueOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = getLlvmInterpreterProxy()->floatValueOf(object);
        </semantic>

    </instruction>

    <instruction opcode="410" mnemonic="boolean32ToOop">
        <name>Boolean to Oop</name>
        <description>It converts an integer representing a boolean into an oop</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = value ? interpreterProxy->trueObject() : interpreterProxy->falseObject();
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt32(0));
            object = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());
        </semantic>

    </instruction>

    <instruction opcode="411" mnemonic="boolean64ToOop">
        <name>Boolean to Oop</name>
        <description>It converts an integer representing a boolean into an oop</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = value ? interpreterProxy->trueObject() : interpreterProxy->falseObject();
        </semantic>

        <semantic language="C++/LLVM">
            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt64(0));
            object = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());
        </semantic>

    </instruction>

    <instruction opcode="412" mnemonic="smallInt32ToOop">
        <name>SmallInteger32 to Opp</name>
        <description>It converts a small integer into an oop</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->integerObjectOf(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->integerObjectOf(value);
        </semantic>

    </instruction>


    <instruction opcode="413" mnemonic="int32ToOop">
        <name>Int32 to Opp</name>
        <description>It converts a signed integer into an oop</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->signed32BitIntegerFor(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->signed32BitIntegerFor(value);
        </semantic>

    </instruction>

    <instruction opcode="414" mnemonic="uint32ToOop">
        <name>UInt32 to Opp</name>
        <description>It converts an unsigned integer into an oop</description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->positive32BitIntegerFor(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->positive32BitIntegerFor(value);
        </semantic>

    </instruction>

    <instruction opcode="415" mnemonic="int64ToOop">
        <name>Int32 to Opp</name>
        <description>It converts a signed 64-bit integer into an oop</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->signed64BitIntegerFor(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->signed64BitIntegerFor(value);
        </semantic>

    </instruction>

    <instruction opcode="416" mnemonic="uint64ToOop">
        <name>Int32 to Opp</name>
        <description>It converts an unsigned integer into an oop</description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->positive64BitIntegerFor(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->positive64BitIntegerFor(value);
        </semantic>

    </instruction>

    <instruction opcode="417" mnemonic="float32ToOop">
        <name>float32 to Opp</name>
        <description>It converts a single precision IEEE 754 floating point number into an oop</description>
        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->floatObjectOf(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->floatObjectOf(builder.CreateFPCast(value, builder.getDoubleTy()));
        </semantic>

    </instruction>

    <instruction opcode="418" mnemonic="float64ToOop">
        <name>float64 to Opp</name>
        <description>It converts a double precision IEEE 754 floating point number into an oop</description>
        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>
        <stack-results>
            <oop name="object" />
        </stack-results>

        <semantic language="C/Interpreter">
            object = interpreterProxy->floatObjectOf(value);
        </semantic>

        <semantic language="C++/LLVM">
            object = getLlvmInterpreterProxy()->floatObjectOf(value);
        </semantic>
    </instruction>

    <instruction opcode="419" mnemonic="loadObjectField">
        <name>Load an object field.</name>
        <description>This instruction loads the value of an object.</description>

        <arguments>
            <extend-a name="fieldIndex" />
        </arguments>

        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <oop name="field" />
        </stack-results>

        <semantic language="C/Interpreter">
            field = interpreterProxy->fetchPointerofObject(fieldIndex, object);
        </semantic>

        <semantic language="C++/LLVM">
            field = getLlvmInterpreterProxy()->fetchPointerofObject(fieldIndex, object);
        </semantic>

    </instruction>

    <instruction opcode="420" mnemonic="storeObjectField">
        <name>Store an object field</name>
        <description>This instruction stores an object into a field of an object.</description>

        <arguments>
            <extend-a name="fieldIndex" />
        </arguments>

        <stack-arguments>
            <oop name="object" />
            <oop name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            interpreterProxy->storePointerofObjectwithValue(fieldIndex, object, value);
        </semantic>

        <semantic language="C++/LLVM">
            getLlvmInterpreterProxy()->storePointerofObjectwithValue(fieldIndex, object, value);
        </semantic>

    </instruction>

    <instruction opcode="421" mnemonic="loadObjectAt">
        <name>Load an object field.</name>
        <description>This instruction loads the value of an object.</description>

        <stack-arguments>
            <oop name="object" />
            <int32 name="fieldIndex" />
        </stack-arguments>
        <stack-results>
            <oop name="field" />
        </stack-results>

        <semantic language="C/Interpreter">
            field = interpreterProxy->fetchPointerofObject(fieldIndex, object);
        </semantic>

        <semantic language="C++/LLVM">
            field = getLlvmInterpreterProxy()->fetchPointerofObject(fieldIndex, object);
        </semantic>

    </instruction>

    <instruction opcode="422" mnemonic="storeObjectFieldAt">
        <name>Store an object field</name>
        <description>This instruction stores an object into a field of an object.</description>

        <stack-arguments>
            <oop name="object" />
            <int32 name="fieldIndex" />
            <oop name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            interpreterProxy->storePointerofObjectwithValue(fieldIndex, object, value);
        </semantic>

        <semantic language="C++/LLVM">
            getLlvmInterpreterProxy()->storePointerofObjectwithValue(fieldIndex, object, value);
        </semantic>

    </instruction>

    <instruction opcode="423" mnemonic="firstFieldPointer">
        <name>First Fixed Field</name>
        <description>Loads the first fixed field address of an object into a register.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = interpreterProxy->firstFixedField(object);
        </semantic>

        <semantic language="C++/LLVM">
            pointer = getLlvmInterpreterProxy()->firstFixedField(object);
        </semantic>

    </instruction>

    <instruction opcode="424" mnemonic="firstIndexableFieldPointer">
        <name>First Indexable Field</name>
        <description>Loads the first indexable field address of an object into a register.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = interpreterProxy->firstIndexableField(object);
        </semantic>

        <semantic language="C++/LLVM">
            pointer = getLlvmInterpreterProxy()->firstIndexableField(object);
        </semantic>

    </instruction>

    <instruction opcode="425" mnemonic="byteSizeOf">
        <name>Byte size of object</name>
        <description>It tells the number of variable bytes of an object</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->byteSizeOf(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = getLlvmInterpreterProxy()->byteSizeOf(object);
        </semantic>

    </instruction>

    <!-- Object model testing -->
    <instruction opcode="426" mnemonic="isBytes">
        <name>Is bytes object</name>
        <description>It tells if an object is bytes variable.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isBytes(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isBytes(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="427" mnemonic="isFloatObject">
        <name>Is float object</name>
        <description>It tells if an object is a float.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isFloatObject(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isFloatObject(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="428" mnemonic="isIndexable">
        <name>Is indexable object</name>
        <description>It tells if an object is an indexable.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isIndexable(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isIndexable(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="429" mnemonic="isIntegerObject">
        <name>Is integer object</name>
        <description>It tells if an object is an integer.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isIntegerObject(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isIntegerObject(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="430" mnemonic="isWords">
        <name>Is Words object</name>
        <description>It tells if an object is words variable.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isWords(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isWords(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>


    <instruction opcode="431" mnemonic="isWordsOrBytes">
        <name>Is bytes object</name>
        <description>It tells if an object is bytes variable.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isWordsOrBytes(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isWordsOrBytes(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <instruction opcode="432" mnemonic="isPointers">
        <name>Is pointers object</name>
        <description>It tells if an object contains pointers.</description>
        <stack-arguments>
            <oop name="object" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = interpreterProxy->isPointers(object);
        </semantic>

        <semantic language="C++/LLVM">
            value = builder.CreateIntCast(getLlvmInterpreterProxy()->isPointers(object), builder.getInt32Ty(), false);
        </semantic>

    </instruction>

    <!-- Comparison -->
    <instruction opcode="433" mnemonic="pointerEqual">
        <name>Pointer Equality</name>
        <description>Pointer equality comparison.</description>
        <stack-arguments>
            <pointer name="first" />
            <pointer name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="434" mnemonic="pointerNotEqual">
        <name>Pointer Not Equality</name>
        <description>Pointer not equality comparison.</description>
        <stack-arguments>
            <pointer name="first" />
            <pointer name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpNE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="435" mnemonic="oopEqual">
        <name>Oop Equality</name>
        <description>Oop identity comparison.</description>
        <stack-arguments>
            <oop name="first" />
            <oop name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="436" mnemonic="oopNotEqual">
        <name>Oop Not Equality</name>
        <description>Oop not identity comparison.</description>
        <stack-arguments>
            <oop name="first" />
            <oop name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpNE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="437" mnemonic="int32Equal">
        <name>Int32 Equality</name>
        <description>Int32 equality.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := vcpu word0.
            (first = second) ifTrue: [value value: 1].
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="438" mnemonic="int32NotEqual">
        <name>Int32 Inequality</name>
        <description>Float32 not equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            value := vcpu word0.
            (first = second) ifFalse: [value value: 1].
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpNE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="439" mnemonic="int32Less">
        <name>Int32 Less Than</name>
        <description>Int32 not equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSLT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="440" mnemonic="int32LessEqual">
        <name>Int32 Less or Equal Than</name>
        <description>Int32 less equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSLE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="441" mnemonic="int32Great">
        <name>Int32 Great Than</name>
        <description>Int32 great than.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="442" mnemonic="int32GreatEqual">
        <name>Int32 Great or EqualThan</name>
        <description>Int32 great or equal than.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSGE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="443" mnemonic="uint32Less">
        <name>UInt32 Less Than</name>
        <description>UInt32 not equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint32_t)first) &lt; ((uint32_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpULT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="444" mnemonic="uint32LessEqual">
        <name>UInt32 Less or Equal Than</name>
        <description>UInt32 less equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint32_t)first) &lt;= ((uint32_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpULE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="445" mnemonic="uint32Great">
        <name>UInt32 Great Than</name>
        <description>UInt32 great than.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint32_t)first) &gt; ((uint32_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpUGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="446" mnemonic="uint32GreatEqual">
        <name>UInt32 Great or Equal Than</name>
        <description>UInt32 great or equal than.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint32_t)first) &gt;= ((uint32_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpUGE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="447" mnemonic="int64Equal">
        <name>Int64 Equality</name>
        <description>Int64 equality.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="448" mnemonic="int64NotEqual">
        <name>Int64 Inequality</name>
        <description>Float64 not equal.</description>
        <stack-arguments>
            <int32 name="first" />
            <int32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpNE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="449" mnemonic="int64Less">
        <name>Int64 Less Than</name>
        <description>Int64 not equal.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSLT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="450" mnemonic="int64LessEqual">
        <name>Int64 Less or Equal Than</name>
        <description>Int64 less equal.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSLE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="451" mnemonic="int64Great">
        <name>Int64 Great Than</name>
        <description>Int64 great than.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="452" mnemonic="int64GreatEqual">
        <name>Int64 Great or EqualThan</name>
        <description>Int64 great or equal than.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpSGE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="453" mnemonic="uint64Less">
        <name>UInt64 Less Than</name>
        <description>UInt64 not equal.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint64_t)first) &lt; ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpULT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="454" mnemonic="uint64LessEqual">
        <name>UInt64 Less or Equal Than</name>
        <description>UInt64 less equal.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint64_t)first) &lt;= ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpULE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="455" mnemonic="uint64Great">
        <name>UInt32 Great Than</name>
        <description>UInt64 great than.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint64_t)first) &gt; ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpUGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="456" mnemonic="uint64GreatEqual">
        <name>UInt64 Great or Equal Than</name>
        <description>UInt64 great or equal than.</description>
        <stack-arguments>
            <int64 name="first" />
            <int64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = ((uint64_t)first) &gt;= ((uint64_t)second);
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateICmpUGE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="457" mnemonic="float32Equal">
        <name>Float32 Equality</name>
        <description>Float32 equality.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="458" mnemonic="float32NotEqual">
        <name>Float32 Inequality</name>
        <description>Float32 not equal.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpONE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="459" mnemonic="float32Less">
        <name>Float32 Less Than</name>
        <description>Float32 less than relationship.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOLT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="460" mnemonic="float32LessEqual">
        <name>Float32 Less or Eual Than</name>
        <description>Float32 less or equal than relationship.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOLE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="461" mnemonic="float32Great">
        <name>Float32 Great Than</name>
        <description>Float32 great than relationship.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="462" mnemonic="float32GreatEqual">
        <name>Float32 Great or Equal Than</name>
        <description>Float32 great or equal than relationship.</description>
        <stack-arguments>
            <float32 name="first" />
            <float32 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOGE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="463" mnemonic="float64Equal">
        <name>Float64 Equality</name>
        <description>Float64 equality.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first == second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOEQ(first, second));
        </semantic>

    </instruction>

    <instruction opcode="464" mnemonic="float64NotEqual">
        <name>Float64 Inequality</name>
        <description>Float64 not equal.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first != second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpONE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="465" mnemonic="float64Less">
        <name>Float64 Less Than</name>
        <description>Float64 less than relationship.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOLT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="466" mnemonic="float64LessEqual">
        <name>Float64 Less or Equal Than</name>
        <description>Float32 less or equal than relationship.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &lt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOLE(first, second));
        </semantic>

    </instruction>

    <instruction opcode="467" mnemonic="float64Great">
        <name>Float64 Great Than</name>
        <description>Float64 great than relationship.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt; second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOGT(first, second));
        </semantic>

    </instruction>

    <instruction opcode="468" mnemonic="float64GreatEqual">
        <name>Float64 Great or Equal Than</name>
        <description>Float64 great or equal than relationship.</description>
        <stack-arguments>
            <float64 name="first" />
            <float64 name="second" />
        </stack-arguments>

        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            value = first &gt;= second; 
        </semantic>

        <semantic language="C++/LLVM" >
            value = condToInt32(builder.CreateFCmpOGE(first, second));
        </semantic>

    </instruction>

    <!-- Control Flow -->
    <instruction opcode="469" mnemonic="jump" kind="jump">
        <name>Jump</name>
        <description>Performs an Unconditional Jump</description>
        <arguments>
            <label name="dest" />
        </arguments>

        <semantic language="C/Interpreter">
            pc = dest;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            instruction jumpBlock compiledBlock compileBlock: stack copy.
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateBr(getJumpBlock()->getLlvmBasicBlock());
        </semantic>

    </instruction>

    <instruction opcode="470" mnemonic="branchTrue32" kind="branch">
        <name>Branch On True</name>
        <description>It performs an jump if the Int32 present in the stack is different than zero.</description>

        <arguments>
            <label name="dest" />
        </arguments>

        <stack-arguments>
            <int32 name="cond" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            if(cond)
                pc = dest;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            (cond = vcpu word0) ifFalse: [
                instruction branchBlock compiledBlock compileBlock: stack copy
            ] ifTrue: [
                instruction nextBlock compiledBlock compileBlock: stack copy
            ].
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *boolCond = builder.CreateICmpNE(cond, builder.getInt32(0));
            builder.CreateCondBr(boolCond, getBranchBlock()->getLlvmBasicBlock(),
                                    getNextBlock()->getLlvmBasicBlock());
        </semantic>

    </instruction>

    <instruction opcode="471" mnemonic="branchFalse32" kind="branch">
        <name>Branch On False</name>
        <description>It performs an jump if the Int32 present in the stack is equals to zero.</description>

        <arguments>
            <label name="dest" />
        </arguments>

        <stack-arguments>
            <int32 name="cond" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            if(!cond)
                pc = dest;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            (cond = vcpu word0) ifTrue: [
                instruction branchBlock compiledBlock compileBlock: stack copy
            ] ifFalse: [
                instruction nextBlock compiledBlock compileBlock: stack copy
            ].
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *boolCond = builder.CreateICmpEQ(cond, builder.getInt32(0));
            builder.CreateCondBr(boolCond, getBranchBlock()->getLlvmBasicBlock(),
                                    getNextBlock()->getLlvmBasicBlock());
        </semantic>

    </instruction>

    <instruction opcode="472" mnemonic="branchTrue64" kind="branch">
        <name>Branch On True</name>
        <description>It performs an jump if the Int64 present in the stack is different than zero.</description>

        <arguments>
            <label name="dest" />
        </arguments>

        <stack-arguments>
            <int64 name="cond" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            if(cond)
                pc = dest;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            (cond = vcpu word0) ifFalse: [
                instruction branchBlock compiledBlock compileBlock: stack copy
            ] ifTrue: [
                instruction nextBlock compiledBlock compileBlock: stack copy
            ].
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *boolCond = builder.CreateICmpNE(cond, builder.getInt64(0));
            builder.CreateCondBr(boolCond, getBranchBlock()->getLlvmBasicBlock(),
                                    getNextBlock()->getLlvmBasicBlock());
        </semantic>

    </instruction>

    <instruction opcode="473" mnemonic="branchFalse64" kind="branch">
        <name>Branch On False</name>
        <description>It performs an jump if the Int64 present in the stack is equals to zero.</description>

        <arguments>
            <label name="dest" />
        </arguments>

        <stack-arguments>
            <int32 name="cond" />
        </stack-arguments>

        <stack-results />

        <semantic language="C/Interpreter">
            if(!cond)
                pc = dest;
        </semantic>

        <semantic language="Pharo/VirtualCPU" >
            (cond = vcpu word0) ifTrue: [
                instruction branchBlock compiledBlock compileBlock: stack copy
            ] ifFalse: [
                instruction nextBlock compiledBlock compileBlock: stack copy
            ].
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *boolCond = builder.CreateICmpEQ(cond, builder.getInt64(0));
            builder.CreateCondBr(boolCond, getBranchBlock()->getLlvmBasicBlock(),
                                    getNextBlock()->getLlvmBasicBlock());
        </semantic>

    </instruction>

    <!--    
    <instruction opcode="474" mnemonic="switch8">
        <name>Jump Table 8-bits Values</name>
        <description>Makes a jump table for 8-bits integers.</description>
        <arguments>
            <int-register name="value" />
            <jump-table8 name="jumpTable" />
        </arguments>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>

        <semantic language="Slang">
            "TODO"
        </semantic>
    </instruction>

    <instruction opcode="475" mnemonic="switch16">
        <name>Jump Table 16-bits Values</name>
        <description>Makes a jump table for 16-bits integers.</description>
        <arguments>
            <int-register name="value" />
            <jump-table16 name="jumpTable" />
        </arguments>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>

        <semantic language="Slang">
            "TODO"
        </semantic>
    </instruction>

    <instruction opcode="476" mnemonic="switch32">
        <name>Jump Table 16-bits Values</name>
        <description>Makes a jump table for 32-bits integers.</description>
        <arguments>
            <int-register name="value" />
            <jump-table32 name="jumpTable" />
        </arguments>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>

        <semantic language="Slang">
            "TODO
        </semantic>
    </instruction>

    <instruction opcode="477" mnemonic="switch64">
        <name>Jump Table 64-bits Values</name>
        <description>Makes a jump table for 64-bits integers.</description>
        <arguments>
            <int-register name="value" />
            <jump-table64 name="jumpTable" />
        </arguments>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>

        <semantic language="Slang">
            "TODO
        </semantic>
    </instruction>

-->

    <instruction opcode="478" mnemonic="returnSmallInteger" kind="terminator">
        <name>Return Int32</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->integerObjectOf(value));
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *smallInteger = builder.CreateOr(builder.CreateShl(value, 1), builder.getInt32(1));
            returnOop(smallInteger);
        </semantic>

    </instruction>

    <instruction opcode="479" mnemonic="returnBoolean32AsOop" kind="terminator">
        <name>Return Boolean from Int32</name>
        <description>Returns a boolean </description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(value ? interpreterProxy->trueObject() : interpreterProxy->falseObject());
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt32(0));
            llvm::Value *oop = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());
            returnOop(oop);
        </semantic>

    </instruction>

    <instruction opcode="480" mnemonic="returnBoolean64AsOop" kind="terminator">
        <name>Return Boolean from Int32</name>
        <description>Returns a boolean </description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(value ? interpreterProxy->trueObject() : interpreterProxy->falseObject());
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *cond = builder.CreateICmpNE(value, builder.getInt64(0));
            llvm::Value *oop = builder.CreateSelect(cond, getTrueOopValue(), getFalseOopValue());
            returnOop(oop);
        </semantic>

    </instruction>

    <instruction opcode="481" mnemonic="returnInt32AsOop" kind="terminator">
        <name>Return Int32</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->signed32BitIntegerFor(value));
        </semantic>

        <semantic language="Pharo/VirtualCPU">
            self returnOop: (self interpreterProxy signed32BitIntegerFor: value).
        </semantic>

        <semantic language="C++/LLVM" >
            returnOop(getLlvmInterpreterProxy()->signed32BitIntegerFor(value));
        </semantic>

    </instruction>

    <instruction opcode="482" mnemonic="returnInt64AsOop" kind="terminator">
        <name>Return Int64</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->signed64BitIntegerFor(value));
        </semantic>

        <semantic language="C++/LLVM" >
            returnOop(getLlvmInterpreterProxy()->signed64BitIntegerFor(value));
        </semantic>

    </instruction>

    <instruction opcode="483" mnemonic="returnUInt32AsOop" kind="terminator">
        <name>Return Int32</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->positive32BitIntegerFor(value));
        </semantic>

        <semantic language="C++/LLVM" >
            returnOop(getLlvmInterpreterProxy()->positive32BitIntegerFor(value));
        </semantic>

    </instruction>

    <instruction opcode="484" mnemonic="returnUInt64AsOop" kind="terminator">
        <name>Return Int64</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <int64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->positive64BitIntegerFor(value));
        </semantic>

        <semantic language="C++/LLVM" >
            returnOop(getLlvmInterpreterProxy()->positive64BitIntegerFor(value));
        </semantic>

    </instruction>

    <instruction opcode="485" mnemonic="returnPointerAsOop" kind="terminator">
        <name>Return Pointer</name>
        <description>Returns a pointer </description>

        <arguments>
            <literal name="pointerClassLiteral" />
        </arguments>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            {
                sqInt object = interpreterProxy->instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));
                CHECK_FAILED();
                *((void**)interpreterProxy->firstIndexableField(object)) = pointer;
                RETURN_OOP(object);
            }
        </semantic>

        <semantic language="C++/LLVM">
            // Instantiate the object.
            llvm::Value *object = getLlvmInterpreterProxy()->instantiateClassindexableSize(pointerClassLiteral, sizeof(void*));
            checkFailed();
            
            // Get the field pointer.
            llvm::Value *firstFieldPtr = getLlvmInterpreterProxy()->firstIndexableField(object);
            checkFailed();

            // Store the pointer value.
            llvm::Type *pointerType = llvm::PointerType::getUnqual(builder.getInt8PtrTy());
            builder.CreateStore(pointer, builder.CreatePointerCast(firstFieldPtr, pointerType));

            // Return the object.
            returnOop(object);
        </semantic>

    </instruction>

    <instruction opcode="486" mnemonic="returnFloat32AsOop" kind="terminator">
        <name>Return Float32</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->floatObjectOf(value));
        </semantic>

        <semantic language="C++/LLVM" >
            llvm::Value *float64Value = builder.CreateFPCast(value, builder.getDoubleTy());
            returnOop(getLlvmInterpreterProxy()->floatObjectOf(float64Value));
        </semantic>

    </instruction>

    <instruction opcode="487" mnemonic="returnFloat64AsOop" kind="terminator">
        <name>Return Float64</name>
        <description>Returns an integer </description>
        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            RETURN_OOP(interpreterProxy->floatObjectOf(value));
        </semantic>

        <semantic language="C++/LLVM" >
            returnOop(getLlvmInterpreterProxy()->floatObjectOf(value));
        </semantic>

    </instruction>

    <instruction opcode="488" mnemonic="fail" kind="terminator">
        <name>Returns with an error.</name>
        <description>Return with error </description>

        <semantic language="C/Interpreter">
            return interpreterProxy->primitiveFail();
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateRet(getLlvmInterpreterProxy()->primitiveFail());
        </semantic>

    </instruction>

    <instruction opcode="489" mnemonic="failWithCode" kind="terminator">
        <name>Returns with an error.</name>
        <description>Return with error </description>

        <arguments>
            <extend-a name="errorCode" />
        </arguments>

        <semantic language="C/Interpreter">
            return interpreterProxy->primitiveFailFor(errorCode);
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateRet(getLlvmInterpreterProxy()->primitiveFailFor(errorCode));
        </semantic>
    </instruction>


    <!-- Multi-threading -->
    <instruction opcode="490" mnemonic="lockVM">
        <name>Lock VM</name>
        <description>Locks the VM to the current thread.</description>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>

        <semantic language="Slang">
            "TODO"
        </semantic>
    </instruction>

    <instruction opcode="491" mnemonic="unlockVM">
        <name>Unlock VM</name>
        <description>Unlocks the VM from the current thread.</description>

        <semantic language="C/Interpreter">
            /* TODO */
        </semantic>
    </instruction>

    <!-- Atomic operations -->
    <instruction opcode="492" mnemonic="compareAndSwap32">
        <name>Compare and Swap 32 Bits</name>
        <description>
            Compares a 32 bit value in memory with a reference value,
            if they are equal it swaps the memory location with a new value.
            It returns the old value in the memory location.
            This operation is guaranteed to be atomic.
        </description>

        <stack-arguments>
            <pointer name="check" />
            <int32 name="oldValue" />
            <int32 name="newValue" />
        </stack-arguments>
        <stack-results>
            <int32 name="value" />
        </stack-results>

        <semantic language="C/Interpreter">
            UNIMPLEMENTED();
        </semantic>

        <semantic language="C++/LLVM" >
            value = builder.CreateAtomicCmpXchg(check, oldValue, newValue, llvm::Monotonic);
        </semantic>

    </instruction>

    <instruction opcode="493" mnemonic="alloca32">
        <name>Alloca</name>
        <description>
            Allocates variable sized memory in the stack.
        </description>

        <stack-arguments>
            <int32 name="size" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = (uint8_t*)alloca(size);
        </semantic>

        <semantic language="C++/LLVM" >
            pointer = builder.CreateAlloca(builder.getInt8Ty(), size);
        </semantic>

    </instruction>

    <instruction opcode="494" mnemonic="alloca64">
        <name>Alloca</name>
        <description>
            Allocates variable sized memory in the stack.
        </description>

        <stack-arguments>
            <int64 name="size" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = alloca(size);
        </semantic>

        <semantic language="C++/LLVM" >
            pointer = builder.CreateAlloca(builder.getInt8Ty(), size);
        </semantic>

    </instruction>

    <instruction opcode="495" mnemonic="malloc32">
        <name>Malloc</name>
        <description>
            Allocates memory from heap
        </description>

        <stack-arguments>
            <int32 name="size" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = malloc(size);
        </semantic>

        <semantic language="C++/LLVM" >
            pointer = builder.CreateCall(getMallocFunction(), size);
        </semantic>

    </instruction>

    <instruction opcode="496" mnemonic="malloc64">
        <name>Malloc</name>
        <description>
            Allocates memory from heap
        </description>

        <stack-arguments>
            <int64 name="size" />
        </stack-arguments>
        <stack-results>
            <pointer name="pointer" />
        </stack-results>

        <semantic language="C/Interpreter">
            pointer = malloc(size);
        </semantic>

        <semantic language="C++/LLVM" >
            pointer = builder.CreateCall(getMallocFunction(), size);
        </semantic>

    </instruction>

    <instruction opcode="497" mnemonic="free">
        <name>Frees Memory</name>
        <description>
            Frees previously allocated memory in the heap.
        </description>

        <stack-arguments>
            <pointer name="pointer" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            free(pointer);
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateCall(getFreeFunction(), pointer);
        </semantic>

    </instruction>

    <instruction opcode="498" mnemonic="memcpyFixed">
        <name>Copies a block of memory</name>
        <description>Copies a block of memory</description>

        <arguments>
            <extend-a name="size" />
        </arguments>

        <stack-arguments>
            <pointer name="dest" />
            <pointer name="source" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            memcpy(dest, source, size);
        </semantic>

        <semantic language="C++/LLVM" >
            pointer = builder.CreateCall(getMallocFunction(), size);
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateMemCpy(dest, source, size, 1);
        </semantic>

    </instruction>

    <instruction opcode="499" mnemonic="memcpy32">
        <name>Copies a block of memory</name>
        <description>Copies a block of memory</description>

        <stack-arguments>
            <pointer name="dest" />
            <pointer name="source" />
            <int32 name="size" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            memcpy(dest, source, size);
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateMemCpy(dest, source, size, 1);
        </semantic>

    </instruction>

    <instruction opcode="500" mnemonic="memcpy64">
        <name>Copies a block of memory</name>
        <description>Copies a block of memory</description>

        <stack-arguments>
            <pointer name="dest" />
            <pointer name="source" />
            <int64 name="size" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            memcpy(dest, source, size);
        </semantic>

        <semantic language="C++/LLVM" >
            builder.CreateMemCpy(dest, source, size, 1);
        </semantic>

    </instruction>

    <instruction opcode="501" mnemonic="beginCall">
        <name>Begins a function call.</name>
        <description>Begins a function call</description>

        <arguments>
            <extend-a name="alignment" default="0"/>
        </arguments>

        <semantic language="C/Interpreter">
            BEGIN_CALL(alignment);
        </semantic>

        <semantic language="C++/LLVM" >
            beginCall(alignment);
        </semantic>

    </instruction>

    <instruction opcode="502" mnemonic="callArgumentInt32">
        <name>Pushes Int32 call argument</name>
        <description>Pushes a 32-bit integer to the call stack.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_INT32(value);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentInt32(value);
        </semantic>

    </instruction>

    <instruction opcode="503" mnemonic="callArgumentInt64">
        <name>Push Int64 call argument</name>
        <description>Pushes a 64-bit integer to the call stack.</description>

        <stack-arguments>
            <int32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_INT64(value);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentInt64(value);
        </semantic>

    </instruction>

    <instruction opcode="504" mnemonic="callArgumentPointer">
        <name>Push Pointer call argument</name>
        <description>Pushes a pointer to the call stack.</description>

        <stack-arguments>
            <pointer name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_POINTER(value);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentPointer(value);
        </semantic>

    </instruction>

    <instruction opcode="505" mnemonic="callArgumentStructure">
        <name>Push structure call argument</name>
        <description>Pushes a pointer to the call stack.</description>

        <arguments>
            <extend-a name="structureSize" />
        </arguments>

        <stack-arguments>
            <pointer name="structurePointer" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_STRUCTURE(structurePointer, structureSize);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentStructure(structureSize, structurePointer);
        </semantic>

    </instruction>

    <instruction opcode="506" mnemonic="callArgumentFloat32">
        <name>Push Float32 call argument</name>
        <description>Pushes a 32-bit integer to the call stack.</description>

        <stack-arguments>
            <float32 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_FLOAT32(value);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentFloat32(value);
        </semantic>

    </instruction>

    <instruction opcode="507" mnemonic="callArgumentFloat64">
        <name>Push Float64 call argument</name>
        <description>Pushes a 64-bit integer to the call stack.</description>

        <stack-arguments>
            <float64 name="value" />
        </stack-arguments>

        <semantic language="C/Interpreter">
            CALL_ARGUMENT_FLOAT64(value);
        </semantic>

        <semantic language="C++/LLVM" >
            callArgumentFloat64(value);
        </semantic>

    </instruction>

    <instruction opcode="508" mnemonic="performCallInt32">
        <name>Perform function call.</name>
        <description>Performs a function with I32 result</description>

        <arguments>
            <extend-a name="function" default="0"/>
        </arguments>

        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_INT32((void**)(size_t)function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCall(builder.getInt32Ty(), function);
        </semantic>

    </instruction>

    <instruction opcode="509" mnemonic="performCallInt64">
        <name>Perform function call.</name>
        <description>Performs a function with I64 result</description>

        <arguments>
            <extend-a name="function" default="0"/>
        </arguments>

        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_INT64((void**)(size_t)function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCall(builder.getInt64Ty(), function);
        </semantic>

    </instruction>

    <instruction opcode="510" mnemonic="performCallPointer">
        <name>Perform function call.</name>
        <description>Performs a function with pointer result</description>

        <arguments>
            <extend-a name="function" default="0"/>
        </arguments>

        <stack-results>
            <pointer name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_POINTER((void**)(size_t)function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCall(builder.getInt8PtrTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="511" mnemonic="performCallFloat32">
        <name>Perform function call.</name>
        <description>Performs a function with Float32 result</description>

        <arguments>
            <extend-a name="function" default="0"/>
        </arguments>

        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_FLOAT32((void**)(size_t)function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCall(builder.getFloatTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="512" mnemonic="performCallFloat64">
        <name>Perform function call.</name>
        <description>Performs a function with Float64 result</description>

        <arguments>
            <extend-a name="function" default="0"/>
        </arguments>

        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_FLOAT64((void**)(size_t)function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCall(builder.getDoubleTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="513" mnemonic="performCallIndirectInt32">
        <name>Perform indirect function call.</name>
        <description>It erforms an indirect function with I32 result.</description>

        <stack-arguments>
            <pointer name="function" />
        </stack-arguments>

        <stack-results>
            <int32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_INT32(function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCallIndirect(builder.getInt32Ty(), function);
        </semantic>

    </instruction>

    <instruction opcode="514" mnemonic="performCallIndirectInt64">
        <name>Perform indirect function call.</name>
        <description>It erforms an indirect function with I64 result.</description>

        <stack-arguments>
            <pointer name="function" />
        </stack-arguments>

        <stack-results>
            <int64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_INT64(function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCallIndirect(builder.getInt64Ty(), function);
        </semantic>

    </instruction>

    <instruction opcode="515" mnemonic="performCallIndirectPointer">
        <name>Perform indirect function call.</name>
        <description>It erforms an indirect function with pointer result.</description>

        <stack-arguments>
            <pointer name="function" />
        </stack-arguments>

        <stack-results>
            <pointer name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_POINTER(function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCallIndirect(builder.getInt8PtrTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="516" mnemonic="performCallIndirectFloat32">
        <name>Perform indirect function call.</name>
        <description>It erforms an indirect function with Float32 result.</description>

        <stack-arguments>
            <pointer name="function" />
        </stack-arguments>

        <stack-results>
            <float32 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_FLOAT32(function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCallIndirect(builder.getFloatTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="517" mnemonic="performCallIndirectFloat64">
        <name>Perform indirect function call.</name>
        <description>It erforms an indirect function with Float64 result.</description>

        <stack-arguments>
            <pointer name="function" />
        </stack-arguments>

        <stack-results>
            <float64 name="result" />
        </stack-results>

        <semantic language="C/Interpreter">
            DO_CALL_FLOAT64(function, result);
        </semantic>

        <semantic language="C++/LLVM" >
            result = performCallIndirect(builder.getDoubleTy(), function);
        </semantic>

    </instruction>

    <instruction opcode="518" mnemonic="endCall">
        <name>End a function call.</name>
        <description>It ends a function call by cleaning the stack.</description>

        <semantic language="C/Interpreter">
            END_CALL();
        </semantic>

        <semantic language="C++/LLVM" >
            endCall();
        </semantic>

    </instruction>

    <instruction opcode="519" mnemonic="endCallNoCleanup">
        <name>End a function call.</name>
        <description>It ends a function call without cleaning the stack.</description>

        <semantic language="C/Interpreter">
            END_CALL_NO_CLEANUP();
        </semantic>

        <semantic language="C++/LLVM" >
            endCallNoCleanup();
        </semantic>

    </instruction>

    <!-- Custom Calling Conventions -->
    <instruction opcode="520" mnemonic="plaftormCode">
        <name>Platform Code</name>
        <description>
            Returns the platform code
        </description>

        <stack-arguments />
        <stack-results>
            <int32 name="code" />
        </stack-results>

        <semantic language="C/Interpreter">
            UNIMPLEMENTED();
        </semantic>

    </instruction>

    <instruction opcode="521" mnemonic="lockRegisters">
        <name>Lock Registers</name>
        <description>
            Locks the CPU register. This tells the register allocator that the
            following instructions are going to modify some explicit CPU registers.
        </description>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="522" mnemonic="unlockRegisters">
        <name>Unlock Registers</name>
        <description>
            Unlocks the CPU register. This tells the register allocator that the
            following instructions don't require specific CPU registers.
        </description>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="523" mnemonic="moveInt32ToPhysical">
        <name>Move Int32  To Physical Register</name>
        <description>Moves a value into a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments>
            <int32 name="value"/>
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="524" mnemonic="moveInt64ToPhysical">
        <name>Move Int64 To Physical Register</name>
        <description>Moves a value into a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments>
            <int64 name="value"/>
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="525" mnemonic="movePointerToPhysical">
        <name>Move Pointer To Physical Register</name>
        <description>Moves a value into a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments>
            <pointer name="value"/>
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="526" mnemonic="moveFloat32ToPhysical">
        <name>Move Float32 To Physical Register</name>
        <description>Moves a value into a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments>
            <float32 name="value"/>
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="527" mnemonic="moveFloat64ToPhysical">
        <name>Move Float64 Register To Physical Register</name>
        <description>Moves the content of a logical register into a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments>
            <float64 name="value"/>
        </stack-arguments>
        <stack-results />

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="528" mnemonic="pushPhysicalInt32">
        <name>Push Int32 from physical register</name>
        <description>Pushes an Int32 from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments />
        <stack-results>
            <int32 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="529" mnemonic="pushPhysicalInt64">
        <name>Push Int64 from physical register</name>
        <description>Pushes an Int32 from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments />
        <stack-results>
            <int64 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="530" mnemonic="pushPhysicalPointer">
        <name>Push Pointer from physical register</name>
        <description>Pushes a pointer from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments />
        <stack-results>
            <pointer name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>


    <instruction opcode="531" mnemonic="pushPhysicalFloat32">
        <name>Push Float32 from physical register</name>
        <description>Pushes an Float32 from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments />
        <stack-results>
            <float32 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="532" mnemonic="pushPhysicalFloat64">
        <name>Push Float64 from physical register</name>
        <description>Pushes an Float64 from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <stack-arguments />
        <stack-results>
            <float64 name="value"/>
        </stack-results>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="533" mnemonic="callPhysical">
        <name>Push Int32 from physical register</name>
        <description>Pushes an Int32 from a physical CPU register.</description>

        <arguments>
            <extend-a name="registerID" />
        </arguments>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

    <instruction opcode="534" mnemonic="callInstruction">
        <name>Push Int32 from physical register</name>
        <description>Pushes an Int32 from a physical CPU register.</description>

        <arguments>
            <extend-a name="function" />
        </arguments>

        <semantic language="C/Interpreter">
            UNSUPPORTED();
        </semantic>
    </instruction>

</lowcode>

